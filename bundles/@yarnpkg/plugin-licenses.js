/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-licenses",
factory: function (require) {
var plugin=(()=>{var ce=Object.create,T=Object.defineProperty;var le=Object.getOwnPropertyDescriptor;var de=Object.getOwnPropertyNames,q=Object.getOwnPropertySymbols,pe=Object.getPrototypeOf,Y=Object.prototype.hasOwnProperty,ue=Object.prototype.propertyIsEnumerable;var Z=(e,t,i)=>t in e?T(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,D=(e,t)=>{for(var i in t||(t={}))Y.call(t,i)&&Z(e,i,t[i]);if(q)for(var i of q(t))ue.call(t,i)&&Z(e,i,t[i]);return e};var fe=e=>T(e,"__esModule",{value:!0});var d=e=>{if(typeof require!="undefined")return require(e);throw new Error('Dynamic require of "'+e+'" is not supported')};var W=(e,t)=>{for(var i in t)T(e,i,{get:t[i],enumerable:!0})},me=(e,t,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of de(t))!Y.call(e,o)&&o!=="default"&&T(e,o,{get:()=>t[o],enumerable:!(i=le(t,o))||i.enumerable});return e},p=e=>me(fe(T(e!=null?ce(pe(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);var Ne={};W(Ne,{default:()=>xe});var re=p(d("@yarnpkg/cli")),b=p(d("@yarnpkg/core")),v=p(d("clipanion"));var a=p(d("@yarnpkg/core")),m=p(d("@yarnpkg/fslib"));var R={};W(R,{fs:()=>Pe,getPackagePath:()=>ge});var Q=p(d("@yarnpkg/plugin-pnp")),$=p(d("@yarnpkg/core")),M=p(d("@yarnpkg/fslib")),X=p(d("@yarnpkg/libzip")),ge=async(e,t)=>{he(e);let i=$.structUtils.convertPackageToLocator(t),o={name:$.structUtils.stringifyIdent(i),reference:i.reference},r=_.getPackageInformation(o);if(!r)return null;let{packageLocation:c}=r;return c},_,he=e=>{_||(_=module.require((0,Q.getPnpPath)(e).cjs))},Pe=new M.VirtualFS({baseFs:new M.ZipOpenFS({libzip:(0,X.getLibzipSync)(),readOnlyArchives:!0})});var H={};W(H,{fs:()=>ve,getPackagePath:()=>ye});var V=p(d("@yarnpkg/core")),G=p(d("@yarnpkg/parsers")),k=p(d("@yarnpkg/fslib")),ye=async(e,t)=>{await ke(e);let i=V.structUtils.convertPackageToLocator(t),o=B[V.structUtils.stringifyLocator(i)];if(!o)return null;let r=o.locations[0];return r?k.ppath.join(e.cwd,r):e.cwd},B,ke=async e=>{if(!B){let t=k.ppath.join(e.configuration.projectCwd,k.Filename.nodeModules,".yarn-state.yml");B=(0,G.parseSyml)(await k.xfs.readFilePromise(t,"utf8"))}},ve=k.xfs;var J=e=>{switch(e){case"pnp":return R;case"node-modules":return H;default:throw new Error("Unsupported linker")}};var $e=m.npath.basename(__dirname)==="@yarnpkg"?m.ppath.join(m.npath.toPortablePath(__dirname),"../.."):m.ppath.join(m.npath.toPortablePath(__dirname),".."),ee=async(e,t,i,o,r)=>{let c={},f={children:c},s=await te(e,i,o),u=J(e.configuration.get("nodeLinker"));for(let[n,l]of s.entries()){let C=await u.getPackagePath(e,l);if(C===null)continue;let F=JSON.parse(await u.fs.readFilePromise(m.ppath.join(C,m.Filename.manifest),"utf8")),{license:x,url:y,vendorName:N,vendorUrl:g}=ie(F);c[x]||(c[x]={value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,x),children:{}});let h=a.structUtils.convertPackageToLocator(l),S=a.formatUtils.tuple(a.formatUtils.Type.DEPENDENT,{locator:h,descriptor:n}),K=r?{}:D(D(D({},y?{url:{value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,A("URL",y,t))}}:{}),N?{vendorName:{value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,A("VendorName",N,t))}}:{}),g?{vendorUrl:{value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,A("VendorUrl",g,t))}}:{}),E={value:S,children:K},j=a.structUtils.stringifyLocator(h),ae=c[x].children;ae[j]=E}return f},te=async(e,t,i)=>{let o=new Map,r;if(t){if(i){for(let u of e.workspaces)u.manifest.devDependencies.clear();let s=await a.Cache.find(e.configuration);await e.resolveEverything({report:new a.ThrowReport,cache:s})}r=e.storedDescriptors.values()}else r=e.workspaces.flatMap(s=>{let u=[s.anchoredDescriptor];for(let[n,l]of s.dependencies.entries())i&&s.manifest.devDependencies.has(n)||u.push(l);return u});let c=a.miscUtils.sortMap(r,[s=>a.structUtils.stringifyIdent(s),s=>a.structUtils.isVirtualDescriptor(s)?"0":"1",s=>s.range]),f=new Set;for(let s of c.values()){let u=e.storedResolutions.get(s.descriptorHash);if(!u)continue;let n=e.storedPackages.get(u);if(!n)continue;let{descriptorHash:l}=a.structUtils.isVirtualDescriptor(s)?a.structUtils.devirtualizeDescriptor(s):s;f.has(l)||(f.add(l),o.set(s,n))}return o},ie=e=>{let{name:t,version:i,license:o,licenses:r,repository:c,homepage:f,author:s}=e,n=(()=>{if(o)return z(o);if(r){if(r.length===1)return z(r[0]);if(r.length)return`${r.map(z).join(";")}`}return ne})();return n&&n.indexOf(" AND ")>=0&&(n=n.trim(),n.startsWith("(")&&(n=n.substr(1)),n.endsWith(")")&&(n=n.substr(0,n.length-1)),n=n.split(" AND ").join(";")),{moduleName:t+"@"+i,name:t,version:i,url:(c==null?void 0:c.url)||f,license:n,vendorName:typeof s=="string"?s:s==null?void 0:s.name,vendorUrl:f||(s==null?void 0:s.url)}},ne="UNKNOWN",z=e=>(typeof e!="string"?e.type:e)||ne,A=(e,t,i)=>i?t:`${e}: ${t}`,se=async(e,t,i)=>{let o=await te(e,t,i),r=J(e.configuration.get("nodeLinker")),c=[],f=[],s={};for(let u of o.values()){let n=await r.getPackagePath(e,u);if(n===null)continue;let l=JSON.parse(await r.fs.readFilePromise(m.ppath.join(n,m.Filename.manifest),"utf8")),F=(await r.fs.readdirPromise(n,{withFileTypes:!0})).filter(g=>g.isFile()).map(({name:g})=>g),x=F.find(g=>{let h=g.toLowerCase();return h==="license"||h.startsWith("license.")||h==="unlicense"||h.startsWith("unlicense.")}),y=ie(l);if(y.moduleName in s)continue;let N=JSON.stringify(y,null,"  ")+`
`;if(x){let g=await r.fs.readFilePromise(m.ppath.join(n,x),"utf8"),h=F.find(E=>{let j=E.toLowerCase();return j==="notice"||j.startsWith("notice.")}),S;h&&(S=await r.fs.readFilePromise(m.ppath.join(n,h),"utf8")),N+=`
${(S?`${g}

NOTICE

${S}`:g).trim()}
`}c.push(N),y.disclaimer=N,f.push(y),s[y.moduleName]=y}return{disclaimers:c,entries:f}};var I=class extends v.Command{constructor(){super(...arguments);this.recursive=v.Option.Boolean("-R,--recursive",!1,{description:"Include transitive dependencies (dependencies of direct dependencies)"});this.production=v.Option.Boolean("--production",!1,{description:"Exclude development dependencies"});this.json=v.Option.Boolean("--json",!1,{description:"Format output as JSON"});this.excludeMetadata=v.Option.Boolean("--exclude-metadata",!1,{description:"Exclude dependency metadata from output"})}async execute(){let t=await b.Configuration.find(this.context.cwd,this.context.plugins),{project:i,workspace:o}=await b.Project.find(t,this.context.cwd);if(!o)throw new re.WorkspaceRequiredError(i.cwd,this.context.cwd);await i.restoreInstallState();let r=await ee(i,this.json,this.recursive,this.production,this.excludeMetadata);b.treeUtils.emitTree(r,{configuration:t,stdout:this.context.stdout,json:this.json,separators:1})}};I.paths=[["licenses","list"]],I.usage=v.Command.Usage({description:"display the licenses for all packages in the project",details:`
      This command prints the license information for packages in the project. By default, only direct dependencies are listed.

      If \`-R,--recursive\` is set, the listing will include transitive dependencies (dependencies of direct dependencies).

      If \`--production\` is set, the listing will exclude development dependencies.
    `,examples:[["List all licenses of direct dependencies","$0 licenses list"],["List all licenses of direct and transitive dependencies","$0 licenses list --recursive"],["List all licenses of production dependencies only","$0 licenses list --production"]]});var oe=p(d("@yarnpkg/cli")),O=p(d("@yarnpkg/core")),P=p(d("clipanion"));var w=p(d("fs")),L=p(d("path")),U=class extends P.Command{constructor(){super(...arguments);this.recursive=P.Option.Boolean("-R,--recursive",!1,{description:"Include transitive dependencies (dependencies of direct dependencies)"});this.production=P.Option.Boolean("--production",!1,{description:"Exclude development dependencies"});this.outputStdout=P.Option.Boolean("--stdout",!1,{description:"Output the unified licenses in stdout"});this.outputFile=P.Option.String("--outputFile",null,{description:"Output the unified licenses in a file"});this.outputCsv=P.Option.String("--outputCsv",null,{description:"Specify where to output a csv that contains all the"});this.outputDir=P.Option.String("--outputDir",null,{description:"Output split license files in the specified directory"})}async execute(){var s,u;let t=await O.Configuration.find(this.context.cwd,this.context.plugins),{project:i,workspace:o}=await O.Project.find(t,this.context.cwd);if(!o)throw new oe.WorkspaceRequiredError(i.cwd,this.context.cwd);await i.restoreInstallState();let{disclaimers:r,entries:c}=await se(i,this.recursive,this.production);if((s=this.outputCsv)==null?void 0:s.length){let n=`"module name","name","version","repository","url","licenses"
`;for(let l of c)n+=JSON.stringify(l.moduleName)+",",n+=JSON.stringify(l.name)+",",n+=JSON.stringify(l.version)+",",n+=JSON.stringify(l.url)+",",n+='"",',n+=JSON.stringify(l.license)+`
`;(0,w.mkdirSync)((0,L.dirname)(this.outputCsv),{recursive:!0}),(0,w.writeFileSync)(this.outputCsv,n)}if((u=this.outputDir)==null?void 0:u.length)for(let n of c){let l=(0,L.join)(this.outputDir,n.name+"-"+n.version,"npm-license.txt");(0,w.mkdirSync)((0,L.dirname)(l),{recursive:!0}),(0,w.writeFileSync)(l,n.disclaimer)}let f=r.join(`
------------

`);f+=`
`,this.outputFile&&((0,w.mkdirSync)((0,L.dirname)(this.outputFile),{recursive:!0}),(0,w.writeFileSync)(this.outputFile,f)),this.outputStdout&&this.context.stdout.write(f)}};U.paths=[["licenses","generate-disclaimer"]],U.usage=P.Command.Usage({description:"display the license disclaimer including all packages in the project",details:`
      This command prints the license disclaimer for packages in the project. By default, only direct dependencies are listed.

      If \`-R,--recursive\` is set, the disclaimer will include transitive dependencies (dependencies of direct dependencies).

      If \`--production\` is set, the disclaimer will exclude development dependencies.
    `,examples:[["Include licenses of direct dependencies","$0 licenses generate-disclaimer"],["Include licenses of direct and transitive dependencies","$0 licenses generate-disclaimer --recursive"],["Include licenses of production dependencies only","$0 licenses list --production"]]});var we={commands:[I,U]},xe=we;return Ne;})();
return plugin;
}
};
